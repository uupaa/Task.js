<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">

<title>Task.js</title>

<meta name="description" content="Task.js">    

  <meta name="author" content="A very simple way to wait for asynchronius processes." />

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/default.css" id="theme">


<!-- For syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">


<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
  document.write( '<link rel="stylesheet" href="css/print/' +
    ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + 
    '.css" type="text/css" media="print">' );
</script>
<script src="./assets/js/Task.js"></script>

<!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section>
<h1>Task.js</h1>
<h3>A very simple way to wait for asynchronius processes.</h3>
<p>
<h4><span class="citation" data-cites="uupaa">@uupaa</span> - 2014-02-14</h4>
</p>
</section>  


<!-- ----------------------------------------------------- -->

<!-- ----------------------------------------------------- -->

<section id="javascript-async-idiom" class="level1">
<h1>JavaScript, Async, Idiom</h1>
<section id="javascript-は非同期処理の塊" class="level2">
<h2>JavaScript は非同期処理の塊</h2>
<ul>
<li>XHR</li>
<li>onload</li>
<li>setTimeout</li>
<li>postMessage</li>
<li>addEventListener</li>
<li>DOMContentLoaded</li>
</ul>
</section>
<section id="section" class="level2">
<h2></h2>
<p>非同期プログラミングを支援するイディオムには、<br />Deferred, Promises, async, await, DOM Promise, Flow.js などがありますが…</p>
</section>
<section id="section-1" class="level2">
<h2></h2>
<p>今日紹介する <strong><a href="https://github.com/uupaa/Task.js">Task.js</a></strong> も、非同期プログラミングを支援するライブラリです。</p>
<hr />
<p>( Task.js は <strong><a href="http://www.slideshare.net/uupaa/flowjs">Flow.js</a></strong><a href="#section"></a> の改良版です )</p>
</section>
<section id="section-2" class="level2">
<h2></h2>
<p><strong>Task.js</strong> は、Node.js, Browser, WebWorker 上で動作し、かつ軽量です。<br />環境に依存するコードや複雑なトリックも使っていないため、どこでも動作します。</p>
</section>
<section id="section-3" class="level2">
<h2></h2>
<p>Task.js を導入すると、非同期処理やブラウザのサポート状況に悩まさず、 ロジックのコーディングに集中できます。</p>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="非同期処理へのneedsとwants" class="level1">
<h1>非同期処理へのNeedsとWants</h1>
<section id="複数の非同期処理の完了を待ちたい" class="level2">
<h2>複数の非同期処理の完了を待ちたい</h2>
<ul>
<li>ダウンロードの完了を待ちつつアニメーションしたい</li>
<li>いくつかの非同期処理をグルーピングし、 それらの終了を待ちたい事がよくある</li>
<li>同期/非同期が混在すると、場当たり的に、 一方はループで、一方はコールバックの連鎖で制御している</li>
<li>同期/非同期を意識せずに扱いたい</li>
<li>毎回同じようなコードを書いて捨てている気がする</li>
</ul>
</section>
<section id="シンプルな実装がほしい" class="level2">
<h2>シンプルな実装がほしい</h2>
<ul>
<li>Deferred や Promises を JavaScript に詳しくない人や、<br /> 非プログラマーに説明するのは骨が折れる</li>
</ul>
</section>
<section id="運用で困らないようにしたい" class="level2">
<h2>運用で困らないようにしたい</h2>
<ul>
<li>特定の環境に依存したり、頻繁に更新される重厚なライブラリには依存したくない(できない)</li>
</ul>
</section>
<section id="デバッグのしやすさも大事" class="level2">
<h2>デバッグのしやすさも大事</h2>
<ul>
<li>どの非同期処理で止まっているか、原因を素早く特定できないと困る</li>
<li>コマンド一発で、実行中の同期/非同期関数を一覧したい</li>
</ul>
</section>
<section id="section-4" class="level2">
<h2></h2>
<p>Task.js はこれら全ての<br /><strong>Needs</strong> と <strong>Wants</strong> を満たしてくれます</p>
<hr />
<p>では、Task.js の機能を見て行きましょう</p>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.js-の基本" class="level1">
<h1>Task.js の基本</h1>
<pre class="js"><code>function callback(err) { }
function userTask1() { task.pass(); } // ユーザタスク終了で task.pass() を呼ぶ
function userTask2() { task.miss(); } // ユーザタスク失敗で task.miss() を呼ぶ

var taskCount = 2;
var task = new Task(taskCount, callback);

userTask1();                 // 同期ユーザタスク: すぐに userTask1 を呼ぶ
setTimeout(userTask1, 1000); // 非同期ユーザタスク: 1000ms待ってから userTask1 を呼ぶ</code></pre>
<section id="section-5" class="level2">
<h2></h2>
<ul>
<li>Task.js では、ユーザが用意する同期/非同期処理を<br /> <strong>ユーザータスク</strong> と呼びます</li>
<li>var task = new Task( <strong>taskCount</strong>, ... ) は、<strong>task.pass()</strong> が2回呼ばれるのを <strong>待ちます</strong></li>
<li>task.pass() が2回呼ばれると、待機を終了し <strong>callback</strong> を呼びます</li>
</ul>
</section>
<section id="section-6" class="level2">
<h2></h2>
<ul>
<li>task.pass() を2回呼ぶと <strong>待機成功</strong> で終了します</li>
<li>task.miss() を1回でも呼ぶと <strong>待機失敗</strong> で終了します</li>
<li>callback( <strong>err</strong> ) は待機成功で null,<br /> 待機失敗で Error オブジェクトになります</li>
</ul>
</section>
<section id="まとめ" class="level2">
<h2>まとめ</h2>
<ol type="1">
<li><strong>new Task</strong>(taskCount) で待機開始</li>
<li>ユーザタスク成功で <strong>task.pass()</strong> を、<br /> 失敗で <strong>task.miss()</strong> を呼ぶ</li>
<li>待機終了で <strong>callback</strong> が呼ばれる</li>
</ol>
</section>
<section id="section-7" class="level2">
<h2></h2>
<p>Task.js の基本はこれだけです。</p>
<hr />

<p>では次に 応用編です。</p>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task-の応用" class="level1">
<h1>Task の応用</h1>
<section id="section-8" class="level2">
<h2></h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">用法</th>
<th style="text-align: left;">API</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">バッファ</td>
<td style="text-align: left;">callback(buffer), task.buffer()</td>
</tr>
<tr class="even">
<td style="text-align: left;">デバッグ</td>
<td style="text-align: left;">Task.dump(), Task.drop()</td>
</tr>
<tr class="odd">
<td style="text-align: left;">強制終了</td>
<td style="text-align: left;">task.exit(), task.message()</td>
</tr>
<tr class="even">
<td style="text-align: left;">待機数を拡張</td>
<td style="text-align: left;">task.extend()</td>
</tr>
<tr class="odd">
<td style="text-align: left;">失敗を許容</td>
<td style="text-align: left;">task.missable()</td>
</tr>
<tr class="even">
<td style="text-align: left;">Arrayを変換</td>
<td style="text-align: left;">Task.flatten(), Task.arraynize(), Task.objectize()</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Taskを連結</td>
<td style="text-align: left;">Junction, Task.run()</td>
</tr>
</tbody>
</table>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="buffer" class="level1">
<h1>buffer</h1>
<section id="task.buffer" class="level2">
<h2>task.buffer()</h2>
<pre class="js"><code>function callback(err, buffer) {
    console.log(buffer[0]);   // -&gt; &quot;value1&quot;
    console.log(buffer.key2); // -&gt; &quot;value2&quot;
}

var task = new Task(1, callback);

task.push(&quot;value1&quot;);
task.set(&quot;key2&quot;, &quot;value2&quot;);
task.pass();</code></pre>
<ul>
<li>buffer はデータの入れ物(配列)です</li>
<li>buffer に値を設定し callback で値を受け取る事ができます</li>
<li><strong>task.push(value)</strong> は buffer.push(value) を行います</li>
<li><strong>task.set(key,value)</strong> は buffer[key] = value を行います</li>
<li><strong>task.buffer()</strong> からもアクセスできます</li>
</ul>
</section>
<section id="shared-buffer" class="level2">
<h2>Shared Buffer</h2>
<pre class="js"><code>function callback(err, buffer) { // sharedBuffer: [&quot;junction&quot;, &quot;value1&quot;, &quot;value2&quot;]
    console.log(buffer.length); // -&gt; 3
}

var junction = new Task(2, callback).push(&quot;junction&quot;);
var task1    = new Task(1, junction);
var task2    = new Task(1, junction);

task1.push(&quot;value1&quot;).pass();
task2.push(&quot;value2&quot;).pass();</code></pre>
<ul>
<li>後述する Junction を使い、階層構造をもった Task は、<br /> お互いの <strong>buffer を共有した状態</strong> になります</li>
<li>task1.push(&quot;value1&quot;) は junction.push(&quot;value1&quot;) と <strong>同じ結果</strong> になり<br /> task2.push(&quot;value2&quot;) も junction.push(&quot;value2&quot;) と同じ結果になります</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.dump" class="level1">
<h1>Task.dump()</h1>
<section id="task-一覧のダンプ" class="level2">
<h2>Task 一覧のダンプ</h2>
<pre class="js"><code>Task.dump();
{
    &quot;anonymous@165&quot;: { junction: false, taskCount: 1, missableCount: 0, missedCount: 0, passedCount: 0, state: &quot;&quot; }
    &quot;anonymous@166&quot;: { junction: false, taskCount: 1, missableCount: 0, missedCount: 0, passedCount: 0, state: &quot;&quot; }
    &quot;anonymous@167&quot;: { junction: false, taskCount: 1, missableCount: 0, missedCount: 0, passedCount: 0, state: &quot;&quot; }
}</code></pre>
<!--
<input type="button" onclick="console.log(Task.dump())" value="Task.dump()"></input>
 -->

<ul>
<li><strong>Task.dump()</strong> は Task のスナップショットを返します</li>
<li>実行中の Task の一覧と状態を確認できます</li>
</ul>
</section>
<section id="task-名による絞込" class="level2">
<h2>Task 名による絞込</h2>
<pre class="js"><code>var task = new Task(1, callback, { name: &quot;TEST&quot; });

Task.dump(&quot;TEST&quot;);
{
    &quot;TEST@166&quot;: { junction: false, taskCount: 1, missableCount: 0, missedCount: 0, passedCount: 0, state: &quot;&quot; }
}</code></pre>
<ul>
<li>Task の第三引数で Task 名を指定し、<strong>Task.dump(taskName)</strong> で絞り込めます</li>
</ul>
</section>
<section id="section-9" class="level2">
<h2></h2>
<pre class="js"><code>Task.drop();</code></pre>
<ul>
<li><span style="color:gold">Task.drop()</span> は、スナップショットを生成するための内部的な情報を全て削除します</li>
<li>この情報は、Task の待機終了で自動的に削除されます</li>
<li>通常利用では Task.drop() を明示的に呼ぶ必要はありません</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.exit" class="level1">
<h1>task.exit()</h1>
<pre class="js"><code>function callback(err) { }

var task = new Task(100, callback).missable(100);

task.exit(); // 強制終了 -&gt; callback(new Error(...))</code></pre>
<section id="section-10" class="level2">
<h2></h2>
<ul>
<li><strong>task.exit()</strong> を使うと、 taskCount や missable の状態に関わらず、待機失敗で強制終了します</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.message" class="level1">
<h1>task.message()</h1>
<pre class="js"><code>var task = new Task(1, function(err) {
    console.log(err.message); // -&gt; &quot;O_o&quot;
});

function userTask(task) {
    try {
        throw new Error(&quot;O_o&quot;);
        task.pass();
    } catch (err) {
        task.message(err.message).miss();
    }
}

userTask(task);</code></pre>
<section id="section-11" class="level2">
<h2></h2>
<ul>
<li>例外のハンドリングはユーザタスク側で行い、<strong>task.miss()</strong> を呼んでください</li>
<li><strong>task.message()</strong>を使うと、待機失敗時に callback に渡される Errorオブジェクトのメッセージを設定できます</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.extend" class="level1">
<h1>task.extend()</h1>
<pre class="js"><code>function callback(err) { }

var task = new Task(1, callback);

task.extend(1); // taskCount += 1;
task.pass();    // ユーザタスク成功(taskCountが2なので待機する)
task.pass();    // ユーザタスク失敗(taskCountが2なので終了する) -&gt; callback(null)</code></pre>
<ul>
<li>動的に taskCount を +1 するには、<strong>task.extend(1)</strong> とします</li>
<li>次々にユーザタスクが増えるケースで使います</li>
</ul>
<figure>
<img src="./assets/img/task.extend.png" />
</figure>
<!-- ----------------------------------------------------- -->

</section>
<section id="task.missable" class="level1">
<h1>task.missable()</h1>
<pre class="js"><code>function callback(err) { }

var task = new Task(3, callback);

task.missable(2);
task.miss(); // ユーザタスク失敗(missableが2なので許容する)
task.miss(); // ユーザタスク失敗(missableが2なので許容する)
task.miss(); // ユーザタスク失敗(missableが2なので待機失敗) -&gt; callback(Error)</code></pre>
<section id="section-12" class="level2">
<h2></h2>
<ul>
<li>ユーザタスクが3つあり、そのうち2回まで失敗を許容する場合は、new Task(3).<span style="color:gold">missable(2)</span> とします</li>
<li><strong>task.missable(n)</strong> で失敗を許容する回数を設定できます</li>
<li>task.missable(0) の状態で <strong>task.miss()</strong> を一度でも呼ぶと待機失敗で終了します</li>
<li>初期状態は task.missble(0) です</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="array-utilities" class="level1">
<h1>Array Utilities</h1>
<section id="task.flatten" class="level2">
<h2>Task.flatten()</h2>
<pre class="js"><code>var array = [ [1,2], [3,4] ];

Task.flatten(array); // -&gt; [1, 2, 3, 4]</code></pre>
<ul>
<li><strong>Task.flatten(array)</strong>を使うと、ネストした2次元配列を1次元配列に展開できます。</li>
</ul>
<pre class="js"><code>Task.flatten([ [1,2], [3,4], [ [5,6] ] ]); // -&gt; [1, 2, 3, 4, [5, 6] ]</code></pre>
<ul>
<li>3次元配列は2次元配列になります</li>
</ul>
</section>
<section id="task.arraynize" class="level2">
<h2>Task.arraynize()</h2>
<pre class="js"><code>var array = [1,2,3];
array[&quot;key&quot;] = &quot;value&quot;; // Array にプロパティを追加

Task.arraynize(array); // -&gt; [1, 2, 3] になる</code></pre>
<ul>
<li><strong>Task.arraynize(array)</strong>は、新しい配列を作り array の値をコピーします</li>
<li>array のプロパティ(&quot;key&quot;, &quot;value&quot;)は <strong>コピーしません</strong></li>
</ul>
</section>
<section id="task.objectize" class="level2">
<h2>Task.objectize()</h2>
<pre class="js"><code>var array = [1,2,3];
array[&quot;key&quot;] = &quot;value&quot;; // Array にプロパティを追加

Task.objectize(array); // -&gt; { 0: 1, 1: 2, 2: 3, key: &quot;value&quot; }</code></pre>
<ul>
<li><strong>Task.objectize(array)</strong>は、新しい Object を作り array の値をコピーします</li>
<li>array のプロパティ(&quot;key&quot;, &quot;value&quot;)も <strong>コピーします</strong></li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="junction" class="level1">
<h1>Junction</h1>
<section id="section-13" class="level2">
<h2></h2>
<pre class="js"><code>function callback(err) { }

var junction = new Task(2, callback);

var task1 = new Task(1, junction);
var task2 = new Task(1, junction);</code></pre>
<figure>
<img src="./assets/img/junction.png" />
</figure>
<ul>
<li>他の Task を集約する Task を <strong>Junction(合流点)</strong> と呼びます</li>
<li>Junction を使うと Task の上下関係を記述できます</li>
</ul>
</section>
<section id="section-14" class="level2">
<h2></h2>
<pre class="js"><code>function callback(err) {
    console.log(&quot;finished&quot;);
}

lv1_junction     = new Task(1, callback);
  lv2_junction   = new Task(1, lv1_junction);
    lv3_junction = new Task(1, lv2_junction);
      lv4_task1  = new Task(1, lv3_junction);
      lv4_task2  = new Task(1, lv3_junction);

lv4_task1.pass();
lv4_task2.pass();</code></pre>
<ul>
<li>Junction を重ねる事で、Task の階層構造(<span style="color:gold">Task Tree</span>)を作る事ができます</li>
<li>Junction を設定した Task で <strong>状態が変化</strong> すると 上位の Junction にも <strong>通知</strong> されます</li>
<li>さらに上位の Junction がある場合は <strong>次々に伝播</strong> (バブルアップ)します</li>
</ul>
</section>
<section id="section-15" class="level2">
<h2></h2>
<pre class="js"><code>function callback(err) {
    console.log(&quot;finished&quot;);
}

lv1_junction     = new Task(1, callback);
  lv2_junction   = new Task(1, lv1_junction);
    lv3_junction = new Task(1, lv2_junction);
      lv4_task1  = new Task(1, lv3_junction);
      lv4_task2  = new Task(1, lv3_junction);

lv4_task1.pass();
lv4_task2.pass();</code></pre>
<figure>
<img src="./assets/img/nested.junction.png" />
</figure>
</section>
<section id="section-16" class="level2">
<h2></h2>
<pre class="js"><code>function callback(err) {
    console.log(&quot;finished&quot;);
}

var junction = new Task(2, callback);

var task1 = new Task(1, junction);
var task2 = new Task(1, junction);

task1.pass(); // task1 の待機終了 → 状態変化が junction に通知される
task2.pass(); // task2 の待機終了 → 状態変化が junction にも通知され junction も待機終了</code></pre>
<ul>
<li>task1.pass() で task1 と junction の状態が変化します</li>
<li>task2.pass() で task2 と junction の状態が変化します</li>
<li>task2.pass() のタイミングで junction の待機も終了し、callback が呼ばれます</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="task.run" class="level1">
<h1>Task.run</h1>
<section id="task.run-と-junction" class="level2">
<h2>Task.run と Junction</h2>
<pre class="js"><code>var taskMap = {
    a: function(task) { task.pass(); },
    b: function(task) { task.pass(); },
    c: function(task) { task.pass(); },
    d: function(task) { task.pass(); },
};

var junction = new Task(2, callback); // (a &gt; b) + (c + d) が終わったら callback

Task.run(&quot;a &gt; b&quot;, taskMap, junction); // a を実行後に b を実行
Task.run(&quot;c + d&quot;, taskMap, junction); // c と d を並列実行</code></pre>
<ul>
<li><strong>Task.run</strong> は ユーザタスクの前後関係を定義する機能です</li>
<li>Task の上下関係を定義する <strong>Junction</strong> と Task.run は組み合わせて利用できます</li>
</ul>
</section>
<section id="section-17" class="level2">
<h2></h2>
<pre class="js"><code>function callback(err, buffer) {
}

Task.run(&quot;task_a &gt; task_b + task_c &gt; task_d&quot;, {
    task_a: function(task) { ... },
    task_b: function(task) { ... },
    task_c: function(task) { ... },
    task_d: function(task) { ... }
}, callback);</code></pre>
<ul>
<li><strong>Task.run</strong> を使うと、ユーザタスクの直列/並列動作をシンプルな記法で定義できます</li>
<li>ユーザタスク名を <strong><code>&gt;</code></strong> と <strong><code>+</code></strong> でつなぐ事で、ユーザタスクの前後間の流れを定義していきます</li>
</ul>
</section>
<section id="並列ユーザタスク" class="level2">
<h2>並列ユーザタスク</h2>
<pre class="js"><code>
Task.run(&quot;task_a + task_b&quot;, {
    task_a: function(task) { task.pass(); },
    task_b: function(task) { task.pass(); },
}, callback);</code></pre>
<ul>
<li>並列に実行するユーザタスク を <strong><code>+</code></strong> でつなぐと、それらは同時に実行されます</li>
</ul>
</section>
<section id="直列ユーザタスク" class="level2">
<h2>直列ユーザタスク</h2>
<pre class="js"><code>Task.run(&quot;task_a &gt; task_b&quot;, {
    task_a: function(task) { task.pass(); },
    task_b: function(task) { task.pass(); },
}, callback);</code></pre>
<ul>
<li>直列に実行するユーザタスクを <strong><code>&gt;</code></strong> でつなぐと、それらは順番に実行されます</li>
</ul>
</section>
<section id="遅延ユーザタスク" class="level2">
<h2>遅延ユーザタスク</h2>
<pre class="js"><code>Task.run(&quot;task_a &gt; 1000 &gt; task_b&quot;, {
    task_a: function(task) { task.pass(); },
    task_b: function(task) { task.pass(); },
}, callback);</code></pre>
<ul>
<li>数字を埋め込むと、指定した時間分だけ待機する <strong>何もしない</strong> タスクを動的に生成し実行します</li>
<li>上記の例では、task_a 実行後に <strong>1000ms</strong> 待機し、その後に task_b を実行します</li>
</ul>
</section>
<section id="直列ユーザタスクの省略記法" class="level2">
<h2>直列ユーザタスクの省略記法</h2>
<pre class="js"><code>function task_a(task) { task.pass(); }
function task_b(task) { task.pass(); }
function task_c(task) { task.pass(); }

// このような直列ユーザタスクは
Task.run(&quot;task_a &gt; task_b &gt; task_c&quot;, {
    task_a: task_a,
    task_b: task_b,
    task_c: task_c,
}, callback);

// 配列を使って短く書くことができます
Task.run(&quot;&quot;, [task_a, task_b, task_c], callback);</code></pre>
<ul>
<li>ユーザタスクの配列を指定すると、順番に実行します</li>
</ul>
</section>
<section id="直列並列遅延ユーザタスクを組み合わせる" class="level2">
<h2>直列/並列/遅延ユーザタスクを組み合わせる</h2>
<pre class="js"><code>Task.run(&quot;a &gt; b + c &gt; 1000 &gt; d&quot;, {
    a: function(task) { task.pass(); },
    b: function(task) { task.pass(); },
    c: function(task) { task.pass(); },
    d: function(task) { task.pass(); }
}, callback);</code></pre>
<ul>
<li><strong><code>a &gt; b + c + 1000 &gt; d</code></strong> は、ユーザタスク a 〜 d を以下の順番で実行します
<ol type="1">
<li>a を実行します</li>
<li>a の正常終了で、b と c を同時に実行します</li>
<li>b と c が正常終了すると 1000ms 待機します</li>
<li>1000ms 待機後に d を実行します</li>
<li>d が正常終了すると、callback を呼び出します</li>
</ol></li>
</ul>
</section>
<section id="ユーザタスクに引数を渡す" class="level2">
<h2>ユーザタスクに引数を渡す</h2>
<pre class="js"><code>var args = { a: 1, b: 2, c : 3, d: 4 };
var junction = Task.run(&quot;task_a &gt; task_b + task_c &gt; task_d&quot;, {
        task_a: function(task, args) { console.log(args.a); task.pass(); },
                               ////                //////
        task_b: function(task, args) { console.log(args.b); task.pass(); },
        task_c: function(task, args) { console.log(args.c); task.pass(); },
        task_d: function(task, args) { console.log(args.d); task.pass(); },
    }, function(err, buffer) {
        if (err) {
            console.log(&quot;ng&quot;);
        } else {
            console.log(&quot;ok&quot;);
        }
    }, { args: args });
       //////////////</code></pre>
<ul>
<li>Task.run から起動されるユーザタスク(task_a 〜 task_d)に引数を渡すには、Task.run の第四引数に <span style="color:gold">options.args</span> を設定します</li>
</ul>
</section>
<section id="直列ユーザタスクの途中で失敗すると" class="level2">
<h2>直列ユーザタスクの途中で失敗すると</h2>
<pre class="js"><code>Task.run(&quot;task_a &gt; task_b&quot;, {
    task_a: function(task) { task.miss(); },
    task_b: function(task) { task.pass(); }, // task_b は実行されません
}, callback);</code></pre>
<ul>
<li>直列ユーザタスクの途中で失敗すると後続のユーザタスクは実行されません</li>
<li>task_a が失敗した場合は、後続の task_b は実行しません</li>
</ul>
</section>
<section id="並列ユーザタスクの一部が失敗すると" class="level2">
<h2>並列ユーザタスクの一部が失敗すると</h2>
<pre class="js"><code>Task.run(&quot;task_c + task_d + task_e&quot;, {
    task_c: function(task) {
        setTimeout(function() { task.miss() }, 1000); // 1000ms 後に失敗
    },
    task_d: function(task) { task.pass(); }, // task_c が中断しても task_d は中断しません
    task_e: function(task) { task.pass(); }, // task_c が中断しても task_e は中断しません
}, callback);</code></pre>
<ul>
<li>並列ユーザタスクの一部が失敗しても、同じグループに属する並列実行ユーザタスクは中断しません</li>
<li>task_c が途中で失敗した場合でも、task_d と task_e は中断しません</li>
</ul>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="javascript-vs-promise-vs-task.js" class="level1">
<h1>JavaScript vs Promise vs Task.js</h1>
<section id="section-18" class="level2">
<h2></h2>
<p>「非同期のユーザタスク A, B, C, D を、<br />A,B のグループと C,D のグループに分け、<br />2つのグループの完了を待つ」処理を、<br />それぞれの方法で実装してみます</p>
<ul>
<li>JavaScript</li>
<li>jQuery.Deferred</li>
<li>DOM Promise</li>
<li>Junction</li>
<li>Junction + Task.run</li>
</ul>
</section>
<section id="javascript-version" class="level2">
<h2>JavaScript Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    var taskCount1 = [A, B].length;
    var taskCount2 = [C, D].length;
    var taskCount3 = 2; // Junction

    function A() { setTimeout(function() { done_group1(); }, 10);  }
    function B() { setTimeout(function() { done_group1(); }, 100); }
    function C() { setTimeout(function() { done_group2(); }, 20);  }
    function D() { setTimeout(function() { done_group2(); }, 200); }

    function done_group1() {
        if (--taskCount1 &lt;= 0) { junction(); }
    }
    function done_group2() {
        if (--taskCount2 &lt;= 0) { junction(); }
    }
    function junction() {
        if (--taskCount3 &lt;= 0) { finishedCallback(); }
    }
    A(); B(); C(); D();
}
waitForAsyncProcesses(function(err) { console.log(&quot;finished&quot;); });</code></pre>
</section>
<section id="jquery.deferred-version" class="level2">
<h2>jQuery.Deferred Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    var promises1 = [A(), B()];
    var promises2 = [C(), D()];

    function A() {
        var dfd = jQuery.Deferred();
        setTimeout(function() { dfd.resolve(); }, 10);
        return dfd.promise();
    }
    function B() {
        var dfd = jQuery.Deferred();
        setTimeout(function() { dfd.resolve(); }, 100);
        return dfd.promise();
    }
    function C() {
        var dfd = jQuery.Deferred();
        setTimeout(function() { dfd.resolve(); }, 20);
        return dfd.promise();
    }
    function D() {
        var dfd = jQuery.Deferred();
        setTimeout(function() { dfd.resolve(); }, 200);
        return dfd.promise();
    }

    jQuery.when(
        jQuery.when.apply(null, promises1),
        jQuery.when.apply(null, promises2)
    ).done(function() {
        finishedCallback()
    });
}
waitForAsyncProcesses(function(err) { console.log(&quot;finished&quot;); });</code></pre>
</section>
<section id="dom-promise-version" class="level2">
<h2>DOM Promise Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    function A() {
        return new Promise(function(resolve, reject) { setTimeout(resolve, 10);  });
    }
    function B() {
        return new Promise(function(resolve, reject) { setTimeout(resolve, 100); });
    }
    function C() {
        return new Promise(function(resolve, reject) { setTimeout(resolve, 20);  });
    }
    function D() {
        return new Promise(function(resolve, reject) { setTimeout(resolve, 200); });
    }
    Promise.all([
        Promise.all([A(), B()]),
        Promise.all([C(), D()])
    ]).then(function() {
        finishedCallback(null);
    }).catch(function(err) {
        finishedCallback(err);
    });
}
waitForAsyncProcesses(function(err) { console.log(&quot;finished&quot;); })</code></pre>
</section>
<section id="task-junction-version" class="level2">
<h2>Task( Junction ) Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    var taskMap = {
            A: function(task) { setTimeout(function() { task.pass(); }, 10);  },
            B: function(task) { setTimeout(function() { task.pass(); }, 100); },
            C: function(task) { setTimeout(function() { task.pass(); }, 20);  },
            D: function(task) { setTimeout(function() { task.pass(); }, 200); },
        };
    var junction = new Task(2, finishedCallback);
    var task1 = new Task(2, junction);
    var task2 = new Task(2, junction);

    taskMap.A(task1);
    taskMap.B(task1);
    taskMap.C(task2);
    taskMap.D(task2);
}

waitForAsyncProcesses(function(err) { console.log(&quot;finished&quot;); });</code></pre>
</section>
<section id="task-junction-task.run-version" class="level2">
<h2>Task( Junction ) + Task.run Version</h2>
<pre class="js"><code>function waitForAsyncProcesses(finishedCallback) {
    var taskMap = {
            A: function(task) { setTimeout(function() { task.pass(); }, 10);  },
            B: function(task) { setTimeout(function() { task.pass(); }, 100); },
            C: function(task) { setTimeout(function() { task.pass(); }, 20);  },
            D: function(task) { setTimeout(function() { task.pass(); }, 200); },
        };
    var junction = new Task(2, finishedCallback);

    Task.run(&quot;A &gt; B&quot;, taskMap, junction);
    Task.run(&quot;C &gt; D&quot;, taskMap, junction);
}

waitForAsyncProcesses(function(err) { console.log(&quot;finished&quot;); });</code></pre>
<!-- ----------------------------------------------------- -->
</section>
</section>
<section id="install-and-import-script" class="level1">
<h1>install and import script</h1>
<section id="github" class="level2">
<h2>github</h2>
<pre class="sh"><code>https://github.com/uupaa/Task.js</code></pre>
</section>
<section id="npm-install" class="level2">
<h2>npm install</h2>
<pre class="sh"><code>$ npm install uupaa.task.js</code></pre>
<!--
- モジュール名が **uupaa.** で始まっている理由について
    - npm モジュール名は先願制で、一般名詞や動詞は既に枯渇しています
    - npm モジュール名には、大文字を利用できません
    - このような理由により、致し方なく…
    - uupaa がお供するとお考え下さい

(ε・◇・)з o O ( お伴するよ〜
 -->

</section>
<section id="in-node.js" class="level2">
<h2>in Node.js</h2>
<pre class="js"><code>var Task = require(&quot;uupaa.task.js&quot;);

var task = new Task(1, function(err) {
        console.log(err ? err.message : &quot;ok&quot;);
    });

task.pass();</code></pre>
</section>
<section id="in-browser" class="level2">
<h2>in Browser</h2>
<pre class="js"><code>&lt;script src=&quot;uupaa.task.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
var task = new Task(1, function(err) {
        console.log(err ? err.message : &quot;ok&quot;);
    });

task.pass();
&lt;/script&gt;</code></pre>
</section>
<section id="in-webworkers" class="level2">
<h2>in WebWorkers</h2>
<pre class="js"><code>importScripts(&quot;uupaa.task.js&quot;);

var task = new Task(1, function(err) {
        console.log(err ? err.message : &quot;ok&quot;);
    });

task.pass();</code></pre>
<!-- ----------------------------------------------------- -->

</section>
</section>
<section id="まとめ-1" class="level1">
<h1>まとめ</h1>
<section id="section-19" class="level2">
<h2></h2>
<p>Task.js は以下の特徴を備えています</p>
<ul>
<li><strong>様々な環境で動作</strong> します</li>
<li>構造が <strong>シンプル</strong> で応用が効きます</li>
<li>既存の構造やユーザタスクを <strong>大きく改変しなくても導入可能</strong> です</li>
<li>Junction で <strong>上下関係を定義</strong> し、Task.run で <strong>前後関係を定義</strong> できます</li>
<li>Junction と Task.run を組み合わせて <strong>スッキリ</strong> としたコードが書けます</li>
</ul>
</section>
<section id="section-20" class="level2">
<h2></h2>
<p>(ε・◇・)з o O ( Task.js マジ オススメ</p>
</section>
</section>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: false,

  // available themes are in /css/theme
      theme: Reveal.getQueryHash().theme || 'default', 
  
  // default/cube/page/concave/zoom/linear/fade/none
      transition: Reveal.getQueryHash().transition || 'default',
  
  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
  });

</script>

</body>
</html>
